@startuml
namespace ec2provider {
    interface ComputeManager  {
        + GetCompute(ctx context.Context, pod *v1.Pod) (string, string, error)

    }
    class Ec2Info << (S,Aquamarine) >> {
        + InstanceID string
        + PrivateIP string
        + IAMProfile string
        + SecurityGroups []string
        + RetryCount int

    }
    class Ec2Provider << (S,Aquamarine) >> {
        - rm *manager.ResourceManager
        - internalIP string
        - daemonEndpointPort int32
        - pods *PodCache
        - startTime time.Time
        - podNotifier <font color=blue>func</font>(*v1.Pod)
        - computeManager *computeManager
        - podMonitor *health.PodMonitor
        - defaultHandler *health.CheckHandler
        - warmPool *WarmPoolManager

        + NodeName string
        + EniNode *EniNode

        - launchApplication(ctx context.Context, pod *v1.Pod) (*v0.LaunchApplicationResponse, error)
        - deletePodSkipApp(ctx context.Context, pod *v1.Pod)
        - handlePodStatusUpdate(ctx context.Context, pod *v1.Pod, podStatus v1.PodStatus) error
        - stopPodMonitor(ctx context.Context, metaPod *MetaPod) error
        - terminateApp(ctx context.Context, metaPod *MetaPod) error
        - notifyPodDelete(pod *v1.Pod)

        + CreatePod(ctx context.Context, pod *v1.Pod) error
        + UpdatePod(ctx context.Context, pod *v1.Pod) error
        + DeletePod(ctx context.Context, pod *v1.Pod) error
        + GetPod(ctx context.Context, namespace string, name string) (*v1.Pod, error)
        + GetPodStatus(ctx context.Context, namespace string, name string) (*v1.PodStatus, error)
        + GetPods(ctx context.Context) ([]*v1.Pod, error)
        + NotifyPods(ctx context.Context, f <font color=blue>func</font>(*v1.Pod) )
        + ConfigureNode(ctx context.Context, node *v1.Node)
        + GetContainerLogs(ctx context.Context, namespace string, podName string, containerName string, opts api.ContainerLogOpts) (io.ReadCloser, error)
        + RunInContainer(ctx context.Context, namespace string, podName string, containerName string, cmd []string, attach api.AttachIO) error
        + GetStatsSummary(ctx context.Context) (*statsv1alpha1.Summary, error)
        + PopulateCache(cache *PodCache)

    }
    class EniNode << (S,Aquamarine) >> {
        - name string
        - hostname string
        - lastTransitionTime time.Time

        + Configure(ctx context.Context, k8sNode *v1.Node) (*v1.Node, error)
        + Ping(ctx context.Context) error
        + NotifyNodeStatus(ctx context.Context, cb <font color=blue>func</font>(*v1.Node) )

    }
    class MetaPod << (S,Aquamarine) >> {
        - pod *v1.Pod
        - monitor *health.PodMonitor
        - notifier <font color=blue>func</font>(*v1.Pod)

    }
    class PodCache << (S,Aquamarine) >> {
        - pods <font color=blue>map</font>[string]*MetaPod
        - lock sync.RWMutex

        + GetList() []*MetaPod
        + GetPodList() []*v1.Pod
        + Get(key string) *MetaPod
        + Set(key string, val *MetaPod)
        + UpdatePod(key string, pod *v1.Pod) error
        + Delete(key string)

    }
    class State << (S,Aquamarine) >> {
        + ReadyEC2 <font color=blue>map</font>[string]Ec2Info
        + ProvisioningEC2 <font color=blue>map</font>[string]Ec2Info
        + UnhealthyEC2 <font color=blue>map</font>[string]Ec2Info
        + AllocatedEC2 <font color=blue>map</font>[string]Ec2Info

    }
    class WarmPoolManager << (S,Aquamarine) >> {
        - config []config.WarmPoolConfig
        - provider *Ec2Provider
        - ec2Client *awsutils.Client

        - fillAndMaintain()
        - populateEC2Tags(reason string, pod v1.Pod) []types.TagSpecification
        - createWarmEC2(ctx context.Context, wpCfg config.WarmPoolConfig) error
        - updateEC2Tags(ctx context.Context, instanceID string, reason string, pod v1.Pod) error
        - checkEC2TagsForState(ctx context.Context, input *ec2.DescribeInstancesInput)

        + InitialWarmPoolCreation()
        + CreateWarmEC2(ctx context.Context, wpConfig config.WarmPoolConfig, tags []types.TagSpecification) (string, string, string, []string, error)
        + CheckWarmPoolDepth(ctx context.Context, wpc config.WarmPoolConfig)
        + SetNodeName(node string)
        + RefreshWarmPoolFromEC2(ctx context.Context)
        + GetWarmPoolInstanceIfExist(ctx context.Context) (string, string, bool)
        + TerminateInstance(ctx context.Context, instanceID string) (string, error)

    }
    class computeManager << (S,Aquamarine) >> {
        - ec2Client *awsutils.Client

        - podHasInstance(ctx context.Context, pod *v1.Pod) bool
        - createCompute(ctx context.Context, pod *v1.Pod) (string, string, error)
        - deleteCompute(ctx context.Context, pod *v1.Pod) error

        + GetCompute(ctx context.Context, p *Ec2Provider, pod *v1.Pod) (string, string, error)
        + DeleteCompute(ctx context.Context, p *Ec2Provider, pod *v1.Pod) error

    }
}
"sync.Mutex" *-- "ec2provider.State"

namespace health {
    class CheckHandler << (S,Aquamarine) >> {
        - in <font color=blue>chan</font> *checkResult

        + IsReceiving bool

        - receive(ctx context.Context, wg *sync.WaitGroup)
        - handleCheckResult(ctx context.Context, result *checkResult)

    }
    interface Handler  {
        - receive(ctx context.Context, in <font color=blue>chan</font> <font color=blue>interface</font>{})

    }
    class Monitor << (S,Aquamarine) >> {
        - check <font color=blue>func</font>(context.Context, *Monitor) *checkResult
        - isWatcher bool
        - watcher *Watcher
        - handlerReceiver <font color=blue>chan</font> *checkResult

        + Resource <font color=blue>interface</font>{}
        + Subject Subject
        + Name string
        + Failures int
        + State MonitoringState
        + IsMonitoring bool

        - setWatcherFunc(watch <font color=blue>func</font>(context.Context, *Monitor, *CheckHandler) error)
        - resetFailures()
        - incrementFailures(unhealthyThreshold int)
        - getState() MonitoringState

        + Run(ctx context.Context, wg *sync.WaitGroup)

    }
    class PodMonitor << (S,Aquamarine) >> {
        - config config.HealthConfig
        - pod *v1.Pod
        - handler *CheckHandler
        - monitors []*Monitor
        - isMonitoring bool
        - done <font color=blue>chan</font> bool

        - configureMonitors()
        - monitorLoop(ctx context.Context, done <font color=blue>chan</font> bool)
        - background(ctx context.Context, m *Monitor)

        + Start(ctx context.Context)
        + Stop(ctx context.Context)

    }
    class Watcher << (S,Aquamarine) >> {
        - isWatching bool
        - watch <font color=blue>func</font>(context.Context, *Monitor, *CheckHandler) error
        - done <font color=blue>chan</font> bool
        - results <font color=blue>chan</font> *checkResult

    }
    class checkResult << (S,Aquamarine) >> {
        + Monitor *Monitor
        + Failed bool
        + Message string
        + Timestamp time.Time
        + Data <font color=blue>interface</font>{}

    }
    class health.MonitoringState << (T, #FF7700) >>  {
    }
    class health.Subject << (T, #FF7700) >>  {
    }

' NOTE remaining entries below were manually added
'    Monitor .. MonitoringState
'    Monitor .. Subject

    enum Subject {
         SubjectUnknown Subject = "unknown"
         SubjectVkvma   Subject = "vkvma"
         SubjectApp     Subject = "app"
    }

    enum MonitoringState {
        MonitoringStateUnknown   = "unknown"
        MonitoringStateHealthy   = "healthy"
        MonitoringStateUnhealthy = "unhealthy"
    }

    class CheckHandler implements Handler
}
"sync.RWMutex" *-- "health.Monitor"

@enduml
